[{"content":"Well-thought-through product announcements will help increase feature awareness and engage users with new functionality. Just like sharing your public roadmap, it\u0026rsquo;s also a great way to let potential customers see that you\u0026rsquo;re constantly improving.\nFurther reading Read How to announce product updates and features ","date":"2023-09-07","id":0,"permalink":"/blog/example-post/","summary":"You can use blog posts for announcing product updates and features.","tags":[],"title":"Example Post"},{"content":"","date":"2023-09-07","id":1,"permalink":"/blog/","summary":"","tags":[],"title":"Blog"},{"content":"JavaScript weight: 100 - 300\n","date":"2023-09-07","id":2,"permalink":"/docs/javascript/","summary":"JavaScript weight: 100 - 300","tags":[],"title":"JavaScript"},{"content":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\nFurther reading Read about reference in the Diátaxis framework ","date":"2023-09-07","id":3,"permalink":"/docs/javascript/js-%E5%9F%BA%E7%A1%80/","summary":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.","tags":[],"title":"JS 基础"},{"content":"Git weight: 401 - 450\n","date":"2023-09-07","id":4,"permalink":"/docs/git/","summary":"Git weight: 401 - 450","tags":[],"title":"Git"},{"content":"Git 工作流 sequenceDiagram\rparticipant A as 工作区\rparticipant B as 暂存区\rparticipant C as 本地仓库\rparticipant D as 远程仓库\rD--\u003e\u003eA: 1. clone\rA-\u003e\u003eB: 2. add\rB-\u003e\u003eC: 3. commit\rC-\u003e\u003eD: 4. push\rD--\u003e\u003eC: 5. fetch\rC--\u003e\u003eA: 6. diff\rD--\u003e\u003eA: 7. pull\rclone 将远程仓库的文件复制到本地。 add 将我们修改后的文件添加到暂存区。 我们认为暂存区没问题后通过 commit 提交到本地仓库。 push 将本地仓库的内容更新到远程仓库。 fetch 将远程仓库的内容更新到本地仓库。 fetch 后使用 diff 对比区别两者差异，没问题后合并。 pull 直接将远程仓库的内容更新到工作区。 Git 基础指令 1. 用户设置 设置 username\n$ git config --global user.name \u0026#34;user name\u0026#34;\r设置 email\n$ git config --global user.email \u0026#34;abcd@gmail.com\u0026#34;\r设置初始分支名\n$ git config --global init.defaultBranch main\r2. 在当前目录下初始化 git 管理 $ git init Initialized empty Git repository in X:/xxx/.git/\r3. 查看状态 $ git status On branch master No commits yet Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) temp.md nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track)\r4. 添加文件到暂存区 $ git add temp.md\r5. 提交暂存区文件到本地仓库 $ git commit -m \u0026#34;commit message\u0026#34; [master (root-commit) 4b259ca] 版本 1 1 file changed, 1 insertion(+) create mode 100644 temp.md\r6. 查看 git 记录 $ git log commit 4b259ca3e88ac32ffb2774f509526769224e4c2c (HEAD -\u0026gt; master) Author: Adam \u0026lt;adam.bx.meng@gmail.com\u0026gt; Date: Thu Apr 18 23:18:35 2024 +0800 版本 1\r7. 查看所有分支 $ git branch * main\r8. 创建新分支 $ git branch bad-boy\r9. 切换分支 $ git checkout bad-boy Switched to branch \u0026#39;bad-boy\u0026#39;\r10. 删除分支 $ git branch -d bad-boy # 使用 -D 来强制删除分支 Deleted branch bad-boy (was baac2ba).\r11. 合并分支 $ git merge temp Updating baac2ba..2eebd82 Fast-forward README.md | 2 + content/docs/git/basic.md | 145 ++++++++++++++++++++++++++++++++++++++++++++-- hugo_stats.json | 36 +++++++++++- 3 files changed, 176 insertions(+), 7 deletions(-)\r12. 改变当前分支名称 $ git branch -m main # -M 强制执行\rGitHub 1. 查看本地仓库与远程仓库的联系 $ git remote -v origin https://github.com/xxx/blog-source.git (fetch) origin https://github.com/xxx/blog-source.git (push)\r2. 与远程仓库联系 # add \u0026lt;别名\u0026gt; \u0026lt;仓库地址\u0026gt; $ git remote add origin https://github.com/xxx/blog-source\r3. 同步远程仓库的内容到本地 $ git pull origin main\r注意\n如果远程仓库与本地仓库的提交历史不同，我们可以使用变基。rebase 会让我们本地的提交变为最新的一次提交记录，而将远程仓库的提交记录记录为之前的提交。\n$ git pull --rebase origin main\r合并 Git 操作 1. 合并 add 与 commit $ git commit -am \u0026#34;new\u0026#34; [new 1a7e8f3] new 3 files changed, 167 insertions(+), 7 deletions(-)\r2. 创建分支并切换过去 $ git checkout -b temp Switched to a new branch \u0026#39;temp\u0026#39;\r","date":"2024-04-18","id":5,"permalink":"/docs/git/git-github-%E5%9F%BA%E7%A1%80/","summary":"Git 工作流 sequenceDiagram\rparticipant A as 工作区\rparticipant B as 暂存区\rparticipant C as 本地仓库\rparticipant D as 远程仓库\rD--\u003e\u003eA: 1.","tags":[],"title":"Git \u0026 Github 基础"},{"content":"1.\nssh: connect to host github.com port 22: Connection refused fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists.\r$ vim ~/.ssh/config\rAdd section below to it Host github.com Hostname ssh.github.com Port 443\n","date":"2024-04-19","id":6,"permalink":"/docs/git/%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB/","summary":"1.\nssh: connect to host github.com port 22: Connection refused fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists.","tags":[],"title":"错误汇总"},{"content":"Interview weight: 1000 - 2000\n","date":"2023-09-07","id":7,"permalink":"/docs/interview/","summary":"Interview weight: 1000 - 2000","tags":[],"title":"面试题"},{"content":"JavaScript interview weight: 1001 - 1300\n","date":"2024-04-09","id":8,"permalink":"/docs/interview/javascript/","summary":"JavaScript interview weight: 1001 - 1300","tags":[],"title":"JavaScript"},{"content":"1. 介绍 Promise 意为承诺，是异步编程的一种解决方案，比传统的回调函数更合理、强大。\n在以前处理多层异步操作时，我们通常会这样编写代码：\ndoSomething(function(result) { doSomethingElse(result, function(newResult) { doThridThing(newResult, function(finalResult) { console.log(\u0026#34;得到最终结果: \u0026#34; + finalResult); }, failureCallback); }, failureCallback); }, failureCallback);\r上面的代码阅读困难，这就是经典的回调地狱。\n现在通过 Promise 改写上方代码：\ndoSomething().then((result) =\u0026gt; { return doSomethingElse(result); }).then((newResult) =\u0026gt; { return doThirdThing(newResult); }).then((finalResult) =\u0026gt; { console.log(\u0026#34;得到最终结果: \u0026#34; + finalResult); }).catch(failureCallback);\r我们在这里就能体会到 Promise 解决异步操作时的优点了：\n链式操作降低了编码难度 代码可读性增加 下面我们来正式介绍下 Promise： Promise 对象是一个构造函数，用来生成 Promise 实例\nconst promise = new Promise((resolve, reject) =\u0026gt; {});\rPromise 对象有且仅有三种状态：\npending 进行中 fulfilled 已成功 rejected 已失效 Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject，它们也都是函数。Promise 状态的改变是通过 resolve() 和 reject() 两个函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态。\nresolve 函数用于将 Promise 对象的状态从 pending 转为 fulfilled。 reject 函数用于将 Promise 对象的状态从 pending 转为 rejected。 Promise 对象的状态不受外界影响，只有异步操作的结果可以决定当前处于哪一种状态。 当把一个任务交给 Promise 时，它的状态就是 pending，任务完成时转为 fulfilled，失败时转为 rejected。当状态发生过转换后，之后状态不会再次改变，且任何时候我们都可以得到这个结果。这与事件不同，事件的特点是当我们错过后，是无法得到结果的。\n简单来说的话，Promise 就是一个容器，里面保存着某个未来才会结束的任务（通常为一个异步操作）的结果。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n我们无法取消 Promise，一旦创建，它就会立即执行，无法中途取消，如果不设置回调函数，Promise 内部抛出的错误不会反映到外部，当处于 pending 状态时，无法得知目前进展到哪一阶段（刚刚开始还是即将结束）\n阅读下图我们能轻松了解 Promise 的工作流程：\ngraph LR;\rA([Promise]) -- \"pending -\u003e fulfill\" --\u003e B([\".then(onFUlfillment)\"]) --\u003e F([async actions]) -- return --\u003e D([Promise])\rA([Promise]) -- \"pending -\u003e reject\" --\u003e C([\".then(onRejection)\r.catch(onRejection)\"]) --\u003e E([error handing]) -- return --\u003e D([Promise])\rD -- \"pending -\u003e ...\" --\u003e G([\".then().catch()\"])\r2. 实例方法 我们常用的 Promise 实例方法有以下几种：\n1. then then 是实例状态发生改变时的回调函数，它可以为两个状态的改变注册回调函数，这个回调函数属于微任务，会在本轮事件循环的末尾进行。第一个参数是 resolved 状态的回调函数，第二个参数是 rejected 状态的回调函数。\nthen 方法返回的是一个新的 Promise 实例，这也是 Promise 能够链式书写的原因。\ngetJSON(\u0026#34;/post.json\u0026#34;).then((json) =\u0026gt; { return json.post; }).then((post) =\u0026gt; { // ... });\r2. catch catch() 是 .then(null, rejection) 或 .then(undefined, rejection) 的另一种写法，用于指定发生错误时的回调函数。\ngetJSON(\u0026#34;/posts.json\u0026#34;).then((posts) =\u0026gt; { // ... }).catch((error) =\u0026gt; { console.log(\u0026#34;发生错误！\u0026#34;, error); });\rPromise 对象的错误具有“冒泡”性质，它会一直向后传递，直到被捕获为止。\ngetJSON(\u0026#34;/post/1.json\u0026#34;).then((post) =\u0026gt; { return getJSON(post.commentURL); }).then((comments) =\u0026gt; { // some code }).catch((error) =\u0026gt; { // 处理前面三个 Promise 产生的错误 })\r一般来说，我们使用 then 时往往只有一个参数，这是因为我们可以用 catch 方法代替 then 的第二个参数。\nPromise 对象抛出的错误不会传递到外层代码，即不会有任何反应；\nconst someAsyncThing = () =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { resolve(x + 2); // Reference Error: x is not defined }) }\r这里的代码会抛出错误，但是并不会中断进程。因为 Promise 内部的错误不会影响到外部环境。\ncatch 方法之中还能再抛出错误，通过后面的 catch 去捕获。\n3. finally finally 方法用于指定不管 Promise 对象最后状态如何，都要执行的代码段：\npromise.then((result) =\u0026gt; {...}) .catch((error) =\u0026gt; {...}) .finally(() =\u0026gt; {...})\r3. 构造函数方法 1. all Promise.all() 用于将多个 Promise 包装成一个新的 Promise 实例。\nconst promise = Promise.all([p1, p2, p3]);\r它接受一个数组（迭代对象）作为参数，数组成员都应该是 Promise 实例。\n实例 Promise 的状态由 p1、p2、p3 共同决定，分为两种情况：\n只有 p1、p2、p3 的状态都变为 fulfilled，Promise 实例的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组传递给 Promise 的回调函数。 只要 p1、p2、p3 之中有一个被 rejected，Promise 的状态就变成 rejected。此时第一个被 rejected 的实例的返回值会被传递给 Promise 的回调函数。 注意，如果作为参数的 Promise 实例自己定义了 catch 方法，那么它一旦被 rejected，并不会出发 Promise.all 的 catch 方法。\nconst p1 = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#34;hello\u0026#34;); }).then((result) =\u0026gt; { console.log(\u0026#34;p1 result: \u0026#34;, result); return result; }) .catch((e) =\u0026gt; { console.log(\u0026#34;p1 catch: \u0026#34;, e); return e; }); const p2 = new Promise((resolve, reject) =\u0026gt; { throw new Error(\u0026#34;报错\u0026#34;); }).then((result) =\u0026gt; { console.log(\u0026#34;p2 result: \u0026#34;, result); return result; }) .catch((e) =\u0026gt; { console.log(\u0026#34;p2 catch: \u0026#34;, e); return e; }); const p3 = Promise.all([p1, p2]).then((result) =\u0026gt; { console.log(result); // [\u0026#34;hello\u0026#34;, Error: 报错] }).catch((e) =\u0026gt; console.log(e));\r如果 p2 没有自己的 catch 方法，就会调用 Promise.all 的 catch。\nconst p1 = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#34;hello\u0026#34;); }).then((result) =\u0026gt; result); const p2 = new Promise((resolve, reject) =\u0026gt; { throw new Error(\u0026#34;报错\u0026#34;); }).then((result) =\u0026gt; result); Promise.all([p1, p2]) .then((result) =\u0026gt; console.log(result)) .catch((e) =\u0026gt; console.log(e)); // Error: 报错 2. race Promise.race() 同样是将多个 Promise 实例包装成一个新的 Promise 实例。\nconst p = Promise.race([p1, p2, p3]);\r只要 p1、p2、p3 之中有一个实例的状态发生了改变，p 的状态就会随之改变。率先改变的 Promise 实例的返回值会传递给 p 的回调函数。\nconst p = Promise.race([ fetch(\u0026#34;/resource-that-may-take-a-while\u0026#34;), new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; reject(new Error(\u0026#34;request timeout\u0026#34;)), 5000) }) ]); p.then(console.log).catch(console.error);\r3. allSettled Promise.allSettled() 也是接受一组 Promise 实例作为参数包装成一个新的 Promise 实例。\nconst promise1 = Promise.resolve(3); const promise2 = new Promise((resolve, reject) =\u0026gt; { setTimeout(reject, 100); }); const promises = [promise1, promise2]; Promise.allSettled([promise1, promise2]).then((results) =\u0026gt; { results.forEach((result) =\u0026gt; console.log(result.status)); }); // 输出 // fulfilled // rejected 只有等这些参数实例都返回结果，不管是 fulfilled 还是 rejected，包装实例才会结束。\n4. resolve Promise.resolve() 将现有对象转为 Promise 对象。\nPromise.resolve(\u0026#34;foo\u0026#34;); // 等价于 new Promise((resolve) =\u0026gt; resolve(\u0026#34;foo\u0026#34;));\r参数可分为四种情况：\n参数是一个 Promise 实例，Promise.resolve 将不做任何修改，原封不动的返回这个实例。 参数是一个 thenable 对象，Promise.resolve 会将这个对象转为 Promise 对象然后立即执行 thenable 对象的 then 方法。 参数不是具有 then 方法的对象，或根本不是对象，Promise.resolve 会返回一个新的 Promise 对象，状态为 resolved 没有参数时直接返回一个 resolved 状态的 Promise 对象。 5. reject Promise.reject() 返回一个新的 Promise 实例，该实例的状态为 rejectd。\nconst p = Promise.reject(\u0026#34;出错\u0026#34;); // 等价于 const p = new Promise((resolve, reject) =\u0026gt; reject(\u0026#34;出错\u0026#34;)); p.then(null, (s) =\u0026gt; console.log(s)); // 出错 Promise.reject() 方法的参数会原封不动的变成后续方法的参数：\nPromise.reject(\u0026#34;出错\u0026#34;).catch((e) =\u0026gt; { console.log(e === \u0026#34;出错\u0026#34;); // true });\r4. 使用场景 1. 将图片的加载写成 Promise，一旦加载完成则状态发生改变 const preloadImage = (path) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; }); };\r2. 通过链式操作将多个渲染数据分给不同的 then，让其各司其职。或当下一个异步请求依赖上个请求的结果时，也可以通过链式操作解决问题 // 各司其职 getInfo().then((res) =\u0026gt; { let { bannerList } = res; // 渲染轮播图 console.log(bannerList); return res; }).then((res) =\u0026gt; { let { shortList } = res; // 渲染店铺列表 console.log(shortList); return res; }).then((res) =\u0026gt; { let { categoryList } = res; // 渲染分类列表 console.log(categoryList); return res; });\r3. 通过 all 实现多个请求合并，汇总所有请求结果。比如加载 loading 时，只用设置一个 loading function initLoad() { loading.show() // 加载 loading Promise.all([getBannerList(), getStoreList(), getCategoryList()]).then((res) =\u0026gt; { console.log(res); loading.hide(); // 关闭 loading }).catch((err) =\u0026gt; { console.log(err); loading.hide(); // 关闭 loading }) } initLoad(); // 数据初始化 4. 通过 race 设置图片请求超时 // 请求某个图片资源 function requestImg() { let p = new Promise((resolve, reject) =\u0026gt; { let img = new Image(); img.onload = function() { resolve(img); } // 正确的资源 //img.src = \u0026#34;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg\u0026#34;; img.src = \u0026#34;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1\u0026#34;; }); return p; } // 延时函数，给请求计时 function timeout() { let p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { reject(\u0026#34;图片请求超时\u0026#34;); }, 5000); }); return p; } Promise.race([requestImg(), timeout()]).then((results) =\u0026gt; { console.log(results); }).catch((err) =\u0026gt; { console.log(err); })\r5. 面试回答 Promise 是异步编程的一种解决方案，目的是为了解决传统编写异步操作时的回调地狱问题。 Promise 的优点是链式操作降低了编码难度，代码可读性增加。 Promise 对象有且仅有三种状态：pending，fulfilled，rejected。 Promise 对象是一个构造函数，用于生成 Promise 实例。该函数的两个参数分别是 resolve 和 reject，这两个参数也都是函数。它们的作用是改变 Promise 的状态。resolve 可以将对象从 pending 转为 resolved，reject 将对象从 pending 转为 rejected。 Promise 的状态发生改变后，不会再次改变，且我们任何时候都可以得到这个结果。这与事件不同，事件的特点是错过后无法得到结果。 Promise 一旦创建就无法取消，如果我们不设置回调函数，Promise 内部抛出的错误不会反映到外部。 Promise 的实例方法有 then，catch，finally。 then 是实例状态发生改变时的回调函数，它属于微任务，会在本轮事件循环的末尾进行。它有两个参数，第一个参数是 resolved 状态的回调函数，第二个参数是 rejected 状态的回调函数。then 返回一个新的 Promise 实例，这也是 Promise 能够链式书写的原因。 catch 是 .then(null, rejection) 的简写，用于指定发生错误时的回调函数。Promise 对象的错误具有“冒泡”性质，它会一直往后传递直到被捕获为止。一般来说我们使用的 then 往往只有一个参数，这是因为我们可以用 catch 来代替第二个参数。Promise 抛出的错误不会传递到外部代码，即不会中断进程。 finally 用于指定不管 Promise 对象最后的状态如何都要执行的代码。 Promise 构造函数的方法有 all，race，allSettled，resolve，reject等。 Promise.all()，Promise.race()，Promise.allSettled() 都是将一组 Promise 实例作为参数包装成一个新的 Promise 实例。 假设接受一个有三个 Promise 实例的数组 Promise.all() 是只有三个实例的状态都变为 fulfilled，返回的 Promise 实例的状态才会变成 fulfilled，此时三个实例的返回值作为一个数组传递给这个Promise 实例的回调函数；如果有一个被 rejected，则返回的 Promise 实例被 rejected，此时第一个被 rejected 的实例的返回值会被传递给 Promise 的回调函数。 Promise.race() 则是只要有一个实例的状态发生改变，则返回的 Promise 实例的状态就会随之改变，率先改变的实例的返回值会传递给 Promise 的回调函数。 Promise.allSettled() 则是要三个实例的状态都改变完成后，返回的 Promise 实例才会改变状态。且三个实例的返回值作为数组传给回调函数。 ","date":"2024-04-09","id":9,"permalink":"/docs/interview/javascript/%E8%AF%B4%E8%AF%B4%E5%AF%B9-promise-%E7%9A%84%E7%90%86%E8%A7%A3/","summary":"1. 介绍 Promise 意为承诺，是异步编程的一种解决方案，比传统的回调函数更合理、强大。\n在以前处理多层异步操作时，我们通常会这样编写代码：\ndoSomething(function(result) { doSomethingElse(result, function(newResult) { doThridThing(newResult, function(finalResult) { console.log(\u0026#34;得到最终结果: \u0026#34; + finalResult); }, failureCallback); }, failureCallback); }, failureCallback);\r上面的代码阅读困难，这就是经典的回调地狱。","tags":[],"title":"说说对 Promise 的理解"},{"content":"1. 介绍 闭包就是一个函数与其词法环境（lexical environment）的引用绑在一起。\n也就是说，闭包就是能够读取其他函数内部变量的函数；或是子函数在外调用，子函数所在的父函数的作用域不会被释放。\n在 JavaScript 中，闭包会在满足条件的函数创建时被创建。下面给出一个简单的例子：\nfunction init() { let name = \u0026#34;Mozilla\u0026#34;; // init 内部的局部变量 function displayName() { // 创建了一个闭包，displayName 是内层函数 alert(name); // 使用了父函数中声明的变量 } displayName(); // 使用闭包 } init();\rdisplayName() 虽然没有自己的局部变量，但是由于闭包的特性，它可以访问到外部函数的局部变量。\n2. 使用场景 任何使用闭包的场景都离不开这两点：\n创建私有变量 延长变量的生命周期 一般函数的词法环境在函数返回后就会被销毁，但是闭包会保存创建函数时所在词法环境的引用。即使创建时所在的执行上下文被销毁，但创建时的词法环境依然存在，就达到了延长变量生命周期的目的。\n下面举个例子，在页面上添加一些可以调整字号的按钮：\nfunction makeSizer(size) { return () =\u0026gt; { document.body.style.fontSize = size + \u0026#34;px\u0026#34;; }; } let size12 = makeSizer(12); let size14 = makeSizer(14); let size16 = makeSizer(16); document.getElementById(\u0026#34;size-12\u0026#34;).onclick = size12; document.getElementById(\u0026#34;size-14\u0026#34;).onclick = size14; document.getElementById(\u0026#34;size-16\u0026#34;).onclick = size16;\r柯里化函数 柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的复用。\n// 假设我们有一个求长方形面积的函数 function getArea(width, height) { return width * height; } // 如果我们碰到的长方形的宽总是 10 const area1 = getArea(10, 20); const area2 = getArea(10, 30); const area3 = getArea(10, 40); // 我们可以使用闭包柯里化这个函数 function getArea(width) { return (height) =\u0026gt; { return width * height; } } const getTenWidthArea = getArea(10); // 之后碰到宽度为 10 的长方形就可以这样计算面积 const area1 = getTenWidthArea(20); // 如果碰到宽度变化也可以轻松复用 const getTwentyWidthArea = getArea(20);\r使用闭包模拟私有方法 在 JavaScript 中，并不支持私有变量，但是我们可以用闭包模拟私有方法：\nlet Counter = () =\u0026gt; { let privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: () =\u0026gt; { changeBy(1); }, decrement: () =\u0026gt; { changeBy(-1); }, value: () =\u0026gt; { return privateCounter; }, }; }; let Counter1 = Counter(); let Counter2 = Counter(); console.log(Counter1.value()); // 0 Counter1.increment(); Counter1.increment(); console.log(Counter1.value()); // 2 Counter1.decrement(); console.log(Counter1.value()); // 1 console.log(Counter2.value()); // 0 这里通过闭包创建公共函数，令其可以访问私有函数和变量，这种方式也叫模块模式。\n两个计数器 Counter1 和 Counter2 各自拥有它们的独立性，每次调用其中一个计数器时，改变变量的值会改变这个闭包的词法环境，但是不会影响另一个闭包中的变量。\n3. 注意事项 如果不是特定任务需要使用闭包，在函数中创建闭包时不明智的。因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。\n例如，在创建新的对象和类时，实例方法通常应该关联到对象的原型，而不是定义到对象的构造器中。\n原因在于每个对象的创建，方法都会被重新赋值：\nfunction MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = () =\u0026gt; { console.log(this.name); }; this.getMessage = () =\u0026gt; { console.log(this.message); }; } const ob = new MyObject(\u0026#34;NiderHoger\u0026#34;, \u0026#34;Hello World\u0026#34;); ob.getName();\r上面的代码我们并没有利用到闭包的好处，因此可以避免使用闭包。比如修改成这样：\nfunction MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); } MyObject.prototype = { getName: () =\u0026gt; { console.log(this.name); }, getMessage: () =\u0026gt; { console.log(this.message); }, }; const ob = new MyObject(\u0026#34;NiderHoger\u0026#34;, \u0026#34;Hello World\u0026#34;); ob.getName();\r4. 面试回答 一句话简单概括，闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在父函数的作用域不会被释放。 闭包的使用场景都离不了两点：创建私有变量；延长变量的生命周期。 闭包的原理就是普通函数的词法环境在函数返回时就会被销毁，但闭包会保存创建函数时所在词法环境的引用。即使创建时所在的执行上下文被销毁，但创建时的词法环境依然存在，这样就达到了延长变量生命周期的目的。 如果不是特定任务需要使用闭包，在函数中创建闭包是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能有负面影响。 ","date":"2024-04-11","id":10,"permalink":"/docs/interview/javascript/%E8%AF%B4%E8%AF%B4%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/","summary":"1. 介绍 闭包就是一个函数与其词法环境（lexical environment）的引用绑在一起。\n也就是说，闭包就是能够读取其他函数内部变量的函数；或是子函数在外调用，子函数所在的父函数的作用域不会被释放。\n在 JavaScript 中，闭包会在满足条件的函数创建时被创建。下面给出一个简单的例子：\nfunction init() { let name = \u0026#34;Mozilla\u0026#34;; // init 内部的局部变量 function displayName() { // 创建了一个闭包，displayName 是内层函数 alert(name); // 使用了父函数中声明的变量 } displayName(); // 使用闭包 } init();\rdisplayName() 虽然没有自己的局部变量，但是由于闭包的特性，它可以访问到外部函数的局部变量。","tags":[],"title":"说说对闭包的理解"},{"content":"假设我们这里的操作都以默认数组 fruits 为对象：\nconst fruits = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;];\r1.增 向数组末尾追加一个新元素 push() 向数组末尾追加一个新元素，返回新的数组长度。\nconst newLength = fruits.push(\u0026#34;Orange\u0026#34;); console.log(fruits); // [ \u0026#39;Apple\u0026#39;, \u0026#39;Banana\u0026#39;, \u0026#39;Orange\u0026#39; ] console.log(newLength); // 3 向数组开头添加一个新的元素 unshift() 向数组开头添加一个新的元素，返回数组的新长度。\nconst newLength = fruits.unshift(\u0026#34;Strawberry\u0026#34;); console.log(fruits); // [ \u0026#39;Strawberry\u0026#39;, \u0026#39;Apple\u0026#39;, \u0026#39;Banana\u0026#39; ] console.log(newLength); // 3 将多个数组合并成一个新数组 concat() 可以将多个数组合并成一个新数组，原数组不变。\nconst moreFruits = [\u0026#34;Mango\u0026#34;, \u0026#34;Cherry\u0026#34;]; const combineFruits = fruits.concat(moreFruits); console.log(combinedFruits); // [ \u0026#39;Apple\u0026#39;, \u0026#39;Banana\u0026#39;, \u0026#39;Mango\u0026#39;, \u0026#39;Cherry\u0026#39; ] // 原数组保持不变 console.log(fruits); // [ \u0026#39;Apple\u0026#39;, \u0026#39;Banana\u0026#39; ] 在任意位置插入元素 splice(x, 0, \u0026quot;element\u0026quot;, ...) 可以在 x 位置添加后面的 element 等元素（包括 x 位置），返回空数组。\nlet removedItems = fruits.splice(1, 0, \u0026#34;Cherry\u0026#34;, \u0026#34;Mango\u0026#34;); console.log(fruits); // [ \u0026#39;Apple\u0026#39;, \u0026#39;Cherry\u0026#39;, \u0026#39;Mango\u0026#39;, \u0026#39;Banana\u0026#39; ] console.log(removeItems); // [] 2.删 移除数组中的最后一个元素 pop() 移除数组中的最后一个元素，返回移除的元素。\nconst removeItem = fruits.pop(); console.log(fruits); // [ \u0026#39;Apple\u0026#39; ] console.log(removeItem); // Orange 移除数组中第一个元素 shift() 移除数组中第一个元素，返回移除的元素。\nconst removeItem = fruits.shift(); console.log(fruits); // [ \u0026#39;Banana\u0026#39; ] console.log(removeItem); // Apple 移除数组最后的 N 个元素 splice(-N) 会移除数组最后的 N 个元素，返回移除元素组成的数组。\nconst fruits = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Strawberry\u0026#34;, \u0026#34;Mango\u0026#34;, \u0026#34;Cherry\u0026#34;]; const removeItems = fruits.splice(-3); // 删除数组最后的 3 个元素 console.log(fruits); // [ \u0026#39;Apple\u0026#39;, \u0026#39;Banana\u0026#39; ] console.log(removeItems); // [ \u0026#39;Strawberry\u0026#39;, \u0026#39;Mango\u0026#39;, \u0026#39;Cherry\u0026#39; ] 将数组截断为前 N 个元素 splice(N) 会将数组截断为只有前 N 个元素，返回移除元素组成的数组。\nconst fruits = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Strawberry\u0026#34;, \u0026#34;Mango\u0026#34;, \u0026#34;Cherry\u0026#34;]; const removeItems = fruits.splice(2); // 将数组截断为前 2 个元素 console.log(fruits); // [ \u0026#39;Apple\u0026#39;, \u0026#39;Banana\u0026#39; ] console.log(removeItems); // [ \u0026#39;Strawberry\u0026#39;, \u0026#39;Mango\u0026#39;, \u0026#39;Cherry\u0026#39; ] 从数组固定位置移除多个元素 splice(x, y) 会从索引 x 开始移除 y 个元素，包括 x 所在位置的元素，返回移除元素组成的数组。\nconst fruits = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Strawberry\u0026#34;, \u0026#34;Mango\u0026#34;, \u0026#34;Cherry\u0026#34;]; const removeItems = fruits.splice(2, 1); console.log(fruits); // [ \u0026#39;Apple\u0026#39;, \u0026#39;Banana\u0026#39;, \u0026#39;Mango\u0026#39;, \u0026#39;Cherry\u0026#39; ] console.log(removeItems); // [ \u0026#39;Strawberry\u0026#39; ] 按索引移除元素 splice() 也可以与 indexOf() 结合起来做到按索引移除元素。 const fruits = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Strawberry\u0026#34;, \u0026#34;Mango\u0026#34;]; // 按索引移除单个元素，移除数组中 Banana 元素 const removeItems = fruits.splice(fruits.indexOf(\u0026#34;Banana\u0026#34;), 1); console.log(fruits); // [ \u0026#39;Apple\u0026#39;, \u0026#39;Strawberry\u0026#39;, \u0026#39;Mango\u0026#39; ] console.log(removeItems); // [ \u0026#39;Banana\u0026#39; ] 创建一个包含原数组中一个或多个元素的新数组 slice() 会创建一个包含原数组中一个或多个元素的新数组，该操作不会影响原数组。\nconst fruits = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Strawberry\u0026#34;, \u0026#34;Mango\u0026#34;]; const fruits2 = fruits.slice(1); const fruits3 = fruits.slice(2, 3); console.log(fruits2); // [ \u0026#39;Banana\u0026#39;, \u0026#39;Strawberry\u0026#39;, \u0026#39;Mango\u0026#39; ] console.log(fruits3); // [ \u0026#39;Strawberry\u0026#39; ] 3.改 替换数组中的多个元素 splice() 也能替换数组中的多个元素。 const fruits = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Strawberry\u0026#34;, \u0026#34;Mango\u0026#34;]; // 从 fruits[fruits.length - 2] 开始删除一个元素，并在该位置添加后面两项元素 const removeItems = fruits.splice(-2, 1, \u0026#34;Mango\u0026#34;, \u0026#34;Cherry\u0026#34;); console.log(fruits); // [ \u0026#39;Apple\u0026#39;, \u0026#39;Banana\u0026#39;, \u0026#39;Mango\u0026#39;, \u0026#39;Cherry\u0026#39;, \u0026#39;Mango\u0026#39; ] console.log(removeItems); // [ \u0026#39;Strawberry\u0026#39; ] 4.查 在数组中查找元素的索引 使用 indexOf() 查找元素在数组中的位置，如果没找到则返回 -1。\nconsole.log(fruits.indexOf(\u0026#34;Banana\u0026#34;)); // 1 console.log(fruits.indexOf(\u0026#34;Lemon\u0026#34;)); // -1 检查数组中是否包含某个元素 使用 includes() 检查数组中是否包含某个元素，包含返回 true，否则返回 false。\nconsole.log(fruits.includes(\u0026#34;Banana\u0026#34;)); // true console.log(fruits.includes(\u0026#34;Cherry\u0026#34;)); // false // 如果 indexOf() 不返回 -1，则数组包含给定的元素。 console.log(fruits.indexOf(\u0026#34;Banana\u0026#34;) !== -1); // true console.log(fruits.indexOf(\u0026#34;Cherry\u0026#34;) !== -1); // false 返回第一个与函数匹配的元素 find() 返回与第一个匹配函数逻辑的元素。\nconst people = [ { name: \u0026#34;Matt\u0026#34;, age: 27 }, { name: \u0026#34;Nicholas\u0026#34;, age: 29 }, ]; const under28 = people.find((item, index, array) =\u0026gt; item.age \u0026lt; 28); console.log(under28); // { name: \u0026#39;Matt\u0026#39;, age: 27 } 5. 排序方法 将数组元素反转 reverse() 将数组元素反转。\nfruits.reverse(); console.log(fruits); // [ \u0026#39;Banana\u0026#39;, \u0026#39;Apple\u0026#39; ] 根据函数判断哪项数组元素排在前面 sort() 接受一个比较函数，根据该函数判断数组如何排序。\nfunction compare(value1, value2) { if (value1 \u0026lt; value2) return -1; else if (value2 \u0026gt; value1) return 1; else return 0; } let values = [2, 0, 15, 5, 10]; values.sort(compare); console.log(values); // [ 0, 2, 5, 10, 15 ] 6. 转换方法 从数组中创建一个字符串 下面的例子使用 join() 方法以 fruits 数组为对象返回一个字符串，如果数组为空，则返回空字符串。\nconsole.log(fruits.join(\u0026#34;, \u0026#34;)); // \u0026#34;Apple, Banana\u0026#34; console.log(fruits.join(\u0026#34;\u0026#34;)); // \u0026#34;AppleBanana\u0026#34; console.log([].join(\u0026#34;, \u0026#34;)); // \u0026#34;\u0026#34; 7. 迭代方法 遍历数组的每一个元素的值 使用 for...of 遍历数组的每一个元素。\nfor (const fruit of fruits) { console.log(fruit); } // Apple // Banana 在数组中的每一个元素上都运行一个函数 可以使用 forEach() 在数组中的每一个元素上调用一个函数，没有返回值。\nfruits.forEach((item, index, array) =\u0026gt; { console.log(item, index, array); }); // Apple 0 [ \u0026#39;Apple\u0026#39;, \u0026#39;Banana\u0026#39; ] // Banana 1 [ \u0026#39;Apple\u0026#39;, \u0026#39;Banana\u0026#39; ] 对数组每一项都运行传入的函数，如果有一个元素满足则返回 true，否则返回 false some() 对数组的每一项都运行传入的测试函数，如果至少有一个元素返回 true，则该方法返回 true。\nlet numbers = [1, 2, 3, 4, 5, 6, 7]; let someResult = numbers.some((item, index, array) =\u0026gt; { return item \u0026gt; 3; }); console.log(someResult); // true 对数组每一项都运行传入的函数，如果所有元素都满足则返回 true，否则返回 false every() 对数组的每一项都运行传入的函数，如果所有元素都满足则返回 true。\nlet numbers = [1, 2, 3, 4, 5, 6, 7]; let someResult = numbers.every((item, index, array) =\u0026gt; { return item \u0026gt; 3; }); console.log(someResult); // false 对数组每一项都运行传入的函数，满足条件的元素会组成数组后返回 filter() 对数组的每一项都运行传入的函数，满足 true 的元素会组成数组后返回。\nlet numbers = [1, 2, 3, 4, 5, 6, 7]; let filterResult = numbers.filter((item, index, array) =\u0026gt; { return item % 2 == 0; }); console.log(filterResult); // [ 2, 4, 6 ] 对数组每一项都运行传入的函数，返回由函数每次调用的结果组成的数组 map() 对数组每一项都运行传入的函数，返回由函数每次调用的结果组成的数组。\nlet numbers = [1, 2, 3, 4, 5, 6, 7]; let mapResult = numbers.map((item, index, array) =\u0026gt; { return index * item; }); console.log(mapResult); // [ 0, 2, 6, 12, 20, 30, 42 ] 8. 其它技巧 复制数组 下面展示了四种复制数组的方法：展开语法、from() 方法、 slice() 方法以及 JSON 相关的方法。前三个方法都属于浅拷贝。\n// 浅拷贝 const fruitsCopy = [...fruits]; const fruitsCopy2 = Array.from(fruits); const fruitsCopy3 = fruits.slice(); // 深拷贝 const fruitsDeepCopy = JSON.parse(JSON.stringfy(fruits));\r使用数组将一组值制成表格 const values = []; for (let x = 0; x \u0026lt; 10; x++) { values.push([2 ** x, 2 * x ** 2]); } console.table(values); // ┌─────────┬─────┬─────┐ // │ (index) │ 0 │ 1 │ // ├─────────┼─────┼─────┤ // │ 0 │ 1 │ 0 │ // │ 1 │ 2 │ 2 │ // │ 2 │ 4 │ 8 │ // │ 3 │ 8 │ 18 │ // │ 4 │ 16 │ 32 │ // │ 5 │ 32 │ 50 │ // │ 6 │ 64 │ 72 │ // │ 7 │ 128 │ 98 │ // │ 8 │ 256 │ 128 │ // │ 9 │ 512 │ 162 │ // └─────────┴─────┴─────┘ ","date":"2024-04-11","id":11,"permalink":"/docs/interview/javascript/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","summary":"假设我们这里的操作都以默认数组 fruits 为对象：\nconst fruits = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;];\r1.增 向数组末尾追加一个新元素 push() 向数组末尾追加一个新元素，返回新的数组长度。\nconst newLength = fruits.push(\u0026#34;Orange\u0026#34;); console.log(fruits); // [ \u0026#39;Apple\u0026#39;, \u0026#39;Banana\u0026#39;, \u0026#39;Orange\u0026#39; ] console.","tags":[],"title":"数组的常用方法"},{"content":"1. 前言 在 JavaScript 中，数据类型可以分为两种：\n基本数据类型 复杂数据类型 两者的区别在于存储的方式不同。 2. 基本类型 基本类型主要为以下七种：Number，String，Boolean，Undefined，Null，Symbol，BigInt。\nNumber 数值最常见的整数类型格式是十进制，还可以设置八进制或十六进制。\nlet intNum = 55; // 十进制的 55 let octNum = 070; // 八进制的 56 let hexNum = 0xA; // 十六进制的 10 浮点类型必须包含小数点，还可以通过科学技术法表示。\nlet floatNum1 = 1.1; let floatNujm2 = 3.125e7; // 31250000 在 Number 类型中存在一个特殊值 NaN - not a number。用于表示不是数值，即本来要返回熟知的操作失败了。\nconsole.log(0/0); // NaN String 字符串可以用双引号、单引号或反引号表示。\nlet name1 = \u0026#34;John\u0026#34;; let name2 = \u0026#39;Jacob\u0026#39;; let name3 = `Jinx`;\r字符串是不可变的，一旦创建就无法修改，对字符串的改变操作都是先销毁原字符串在创建一个新的字符串。\nlet lang = \u0026#34;Java\u0026#34;; lang = lang + \u0026#34;Script\u0026#34;; // 先销毁在创建 Boolean 布尔值类型有两个字面量：true 和 false。\n通过 Boolean 可以讲起他类型的数据转化为布尔值，规则如下：\n数据类型 转换为 true 转换为 false String 非空字符串 \u0026quot;\u0026quot; Number 非零数值（包括无穷值） 0、NaN Object 任意对象 null Undefined N/A（不存在） undefined Undefined Undefined 类型只有一个值：undefined。当声明一个变量但未初始化时，就相当于给变量赋予了 undefined 值。\nlet a; console.log(a === undefined); // true 未声明的变量和声明时未初始化的变量是有区别的：\nlet message; // 声明变量却未初始化，值为 undefined console.log(message); // undefined console.log(age); // 没有声明过该变量，报错 Null Null 类型同样只有一个值：null。逻辑上 null 表示不存在任何对象值，但是 typeof 会将其判定为 \u0026quot;object\u0026quot;。\n只要目标位置的预期值是一个对象，但又没有关联的对象可用时就可以使用 null。\nlet car = null; console.log(typeof car); // object （因历史原因不是 null） Symbol Symbol 表示实例为唯一、不可变的数据类型。每个从 Symbol() 返回的 symbol 值都是唯一的，一个 symbol 值能作为对象属性的标识符。这是该数据类型存在的唯一目的。\nlet symbol1 = Symbol(); let symbol2 = Symbol(); console.log(typeof symbol1); // symbol console.log(symbol1 == symbol2); // false 3. 引用类型 复杂数据类型统称为 Object，主要了解以下三种：Object、Array、Function。\nObject 创建对象的常用方式为对象字面量表示法，属性名可以是字符串或数值：\nlet person = { name: \u0026#34;Nicholas\u0026#34;, age: 29, 5: true };\rArray 数组是一组有序的数据。与其他语言不同的是，数组中的每个槽位可以存储任意类型的值，并且数组也是动态大小的。\nlet colors = [\u0026#34;red\u0026#34;, 2, {age: 20}]; colors.push(2);\rFunction 函数其实就是一个对象，每个函数都是 Function 的实例，Function 和其它引用类型一样也有属性和方法。\n函数有着三种常见的表达方式：\n// 函数声明 function sum1 = (num1, num2) { return num1 + num2; } // 函数表达式 const sum2 = function(num1, num2) { return num1 + num2; } // 箭头函数 const sum3 = (num1, num2) =\u0026gt; { return num1 + num2; }\r4. 存储区别 基本数据类型和引用数据类型在内存中的存储位置不同，基本数据类型存储在栈中，引用数据类型存储在堆中。\n基本数据类型 当我们把一个变量赋给另一个变量时，解析器首先要确认这个值是基本类型值还是引用类型值。下面举个例子：\nlet a = 10; let b = a; // 赋值操作 b = 20; console.log(a); // 10 a 的值是基本数据类型，存储在栈中，将 a 的值赋给 b，虽然两个变量的值相等，但是两个变量保存了两个不同的内存地址。\nclassDiagram\rclass 初始栈内存中只有 a {\ra: 10\r}\rclass 栈内存中添加 b 并把 a 复制一份给 b {\ra: 10\rb: 10\r}\rclass b 在栈内存中保存了另一个值 {\ra: 10\rb: 20\r}\r引用数据类型 引用类型数据存放在堆中，每个堆内存对象都有相应的引用地址指向它，而这个引用地址则存储在栈中。\nlet obj1 = {}; let obj2 = obj1; obj2.name = \u0026#34;TXP\u0026#34;; console.log(obj1); // TXP obj1 是一个引用类型，在赋值操作时，实际上是复制了在栈内存储的指向堆内存的指针，所以它们共同指向了同一个堆内存对象，所以更改 obj2 会对 obj1 产生影响。\n4. 面试回答 JavaScript 的数据类型分为两种：基本数据类型和引用数据类型。 基本数据类型有：Number、String、Boolean、Undefined、Null、Symbol、BigInt。 引用数据类型统称为 Object。我们又可以将其分成三小类：通常的 Object、Function 和 Array。 基本数据类型存储在栈中，占据空间小、大小固定，属于被频繁使用的数据类型。 引用数据类型存储在堆中，占据空间大、大小不固定，在栈中存储了指向它们内存起始地址的指针。当使用引用值时，会首先检索其在栈中的地址，取得地址后再从堆中获得实体。 ","date":"2024-04-12","id":12,"permalink":"/docs/interview/javascript/javascript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"1. 前言 在 JavaScript 中，数据类型可以分为两种：\n基本数据类型 复杂数据类型 两者的区别在于存储的方式不同。 2. 基本类型 基本类型主要为以下七种：Number，String，Boolean，Undefined，Null，Symbol，BigInt。\nNumber 数值最常见的整数类型格式是十进制，还可以设置八进制或十六进制。\nlet intNum = 55; // 十进制的 55 let octNum = 070; // 八进制的 56 let hexNum = 0xA; // 十六进制的 10 浮点类型必须包含小数点，还可以通过科学技术法表示。","tags":[],"title":"JavaScript 的数据类型"},{"content":"Css interview weight: 1400 - 1500\n","date":"2024-04-19","id":13,"permalink":"/docs/interview/css/","summary":"Css interview weight: 1400 - 1500","tags":[],"title":"Css"},{"content":"1. border CSS 边框是由上下左右四个方向共同合成的一个框，当盒子长宽为 0 时，它的表现是如何呢？\n\u0026lt;div class=\u0026#34;div1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r.div1 { width: 0; height: 0; background-color: #64c4ed; border-top: 250px solid #f6d365; border-left: 250px solid #a4d7e1; border-right: 250px solid #ed1250; border-bottom: 250px solid #414141; }\rdiv1 的表现如下： 此时我们可以隐藏其中的三个边框，只让一个边框显示。就可以做到绘制一个三角形了:\n.div1 { width: 0; height: 0; border-top: 250px solid transparent; # 设置透明度 border-left: 250px solid transparent; border-right: 250px solid transparent; border-bottom: 250px solid #1d72a6; }\r","date":"2024-04-19","id":14,"permalink":"/docs/interview/css/%E5%A6%82%E4%BD%95%E7%94%A8-css-%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/","summary":"1. border CSS 边框是由上下左右四个方向共同合成的一个框，当盒子长宽为 0 时，它的表现是如何呢？\n\u0026lt;div class=\u0026#34;div1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r.div1 { width: 0; height: 0; background-color: #64c4ed; border-top: 250px solid #f6d365; border-left: 250px solid #a4d7e1; border-right: 250px solid #ed1250; border-bottom: 250px solid #414141; }\rdiv1 的表现如下： 此时我们可以隐藏其中的三个边框，只让一个边框显示。就可以做到绘制一个三角形了:","tags":[],"title":"如何用 CSS 绘制三角形"},{"content":"","date":"2023-09-07","id":15,"permalink":"/docs/","summary":"","tags":[],"title":"Docs"},{"content":"1\n","date":"2023-09-07","id":16,"permalink":"/privacy/","summary":"1","tags":[],"title":"Privacy Policy"},{"content":"","date":"2023-09-07","id":17,"permalink":"/","summary":"","tags":[],"title":"化 道 两 千"},{"content":"","date":"0001-01-01","id":18,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":19,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":20,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]