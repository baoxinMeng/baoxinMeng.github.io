[{"content":"Well-thought-through product announcements will help increase feature awareness and engage users with new functionality. Just like sharing your public roadmap, it\u0026rsquo;s also a great way to let potential customers see that you\u0026rsquo;re constantly improving.\nFurther reading Read How to announce product updates and features ","date":"2023-09-07","id":0,"permalink":"/blog/example-post/","summary":"You can use blog posts for announcing product updates and features.","tags":[],"title":"Example Post"},{"content":"","date":"2023-09-07","id":1,"permalink":"/blog/","summary":"","tags":[],"title":"Blog"},{"content":"","date":"2023-09-07","id":2,"permalink":"/docs/javascript/","summary":"","tags":[],"title":"JavaScript"},{"content":"","date":"2023-09-07","id":3,"permalink":"/docs/interview/","summary":"","tags":[],"title":"面试题"},{"content":"","date":"2024-04-09","id":4,"permalink":"/docs/interview/javascript/","summary":"","tags":[],"title":"JavaScript"},{"content":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\nFurther reading Read about reference in the Diátaxis framework ","date":"2023-09-07","id":5,"permalink":"/docs/javascript/js-%E5%9F%BA%E7%A1%80/","summary":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.","tags":[],"title":"JS 基础"},{"content":"1. 介绍 Promise 意为承诺，是异步编程的一种解决方案，比传统的回调函数更合理、强大。\n在以前处理多层异步操作时，我们通常会这样编写代码：\ndoSomething(function(result) { doSomethingElse(result, function(newResult) { doThridThing(newResult, function(finalResult) { console.log(\u0026#34;得到最终结果: \u0026#34; + finalResult); }, failureCallback); }, failureCallback); }, failureCallback);\r上面的代码阅读困难，这就是经典的回调地狱。\n现在通过 Promise 改写上方代码：\ndoSomething().then((result) =\u0026gt; { return doSomethingElse(result); }).then((newResult) =\u0026gt; { return doThirdThing(newResult); }).then((finalResult) =\u0026gt; { console.log(\u0026#34;得到最终结果: \u0026#34; + finalResult); }).catch(failureCallback);\r我们在这里就能体会到 Promise 解决异步操作时的优点了：\n链式操作降低了编码难度 代码可读性增加 下面我们来正式介绍下 Promise： Promise 对象是一个构造函数，用来生成 Promise 实例\nconst promise = new Promise((resolve, reject) =\u0026gt; {});\rPromise 对象有且仅有三种状态：\npending 进行中 fulfilled 已成功 rejected 已失效 Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject，它们也都是函数。Promise 状态的改变是通过 resolve() 和 reject() 两个函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态。\nresolve 函数用于将 Promise 对象的状态从 pending 转为 fulfilled。 reject 函数用于将 Promise 对象的状态从 pending 转为 rejected。 Promise 对象的状态不受外界影响，只有异步操作的结果可以决定当前处于哪一种状态。 当把一个任务交给 Promise 时，它的状态就是 pending，任务完成时转为 fulfilled，失败时转为 rejected。当状态发生过转换后，之后状态不会再次改变，且任何时候我们都可以得到这个结果。这与事件不同，事件的特点是当我们错过后，是无法得到结果的。\n简单来说的话，Promise 就是一个容器，里面保存着某个未来才会结束的任务（通常为一个异步操作）的结果。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n我们无法取消 Promise，一旦创建，它就会立即执行，无法中途取消，如果不设置回调函数，Promise 内部抛出的错误不会反映到外部，当处于 pending 状态时，无法得知目前进展到哪一阶段（刚刚开始还是即将结束）\n阅读下图我们能轻松了解 Promise 的工作流程：\ngraph LR;\rA([Promise]) -- \"pending -\u003e fulfill\" --\u003e B([\".then(onFUlfillment)\"]) --\u003e F([async actions]) -- return --\u003e D([Promise])\rA([Promise]) -- \"pending -\u003e reject\" --\u003e C([\".then(onRejection)\r.catch(onRejection)\"]) --\u003e E([error handing]) -- return --\u003e D([Promise])\rD -- \"pending -\u003e ...\" --\u003e G([\".then().catch()\"])\r2. 实例方法 我们常用的 Promise 实例方法有以下几种：\n1. then then 是实例状态发生改变时的回调函数，它可以为两个状态的改变注册回调函数，这个回调函数属于微任务，会在本轮事件循环的末尾进行。第一个参数是 resolved 状态的回调函数，第二个参数是 rejected 状态的回调函数。\nthen 方法返回的是一个新的 Promise 实例，这也是 Promise 能够链式书写的原因。\ngetJSON(\u0026#34;/post.json\u0026#34;).then((json) =\u0026gt; { return json.post; }).then((post) =\u0026gt; { // ... });\r2. catch catch() 是 .then(null, rejection) 或 .then(undefined, rejection) 的另一种写法，用于指定发生错误时的回调函数。\ngetJSON(\u0026#34;/posts.json\u0026#34;).then((posts) =\u0026gt; { // ... }).catch((error) =\u0026gt; { console.log(\u0026#34;发生错误！\u0026#34;, error); });\rPromise 对象的错误具有“冒泡”性质，它会一直向后传递，直到被捕获为止。\ngetJSON(\u0026#34;/post/1.json\u0026#34;).then((post) =\u0026gt; { return getJSON(post.commentURL); }).then((comments) =\u0026gt; { // some code }).catch((error) =\u0026gt; { // 处理前面三个 Promise 产生的错误 })\r一般来说，我们使用 then 时往往只有一个参数，这是因为我们可以用 catch 方法代替 then 的第二个参数。\nPromise 对象抛出的错误不会传递到外层代码，即不会有任何反应；\nconst someAsyncThing = () =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { resolve(x + 2); // Reference Error: x is not defined }) }\r这里的代码会抛出错误，但是并不会中断进程。因为 Promise 内部的错误不会影响到外部环境。\ncatch 方法之中还能再抛出错误，通过后面的 catch 去捕获。\n3. finally finally 方法用于指定不管 Promise 对象最后状态如何，都要执行的代码段：\npromise.then((result) =\u0026gt; {...}) .catch((error) =\u0026gt; {...}) .finally(() =\u0026gt; {...})\r3. 构造函数方法 1. all Promise.all() 用于将多个 Promise 包装成一个新的 Promise 实例。\nconst promise = Promise.all([p1, p2, p3]);\r它接受一个数组（迭代对象）作为参数，数组成员都应该是 Promise 实例。\n实例 Promise 的状态由 p1、p2、p3 共同决定，分为两种情况：\n只有 p1、p2、p3 的状态都变为 fulfilled，Promise 实例的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组传递给 Promise 的回调函数。 只要 p1、p2、p3 之中有一个被 rejected，Promise 的状态就变成 rejected。此时第一个被 rejected 的实例的返回值会被传递给 Promise 的回调函数。 注意，如果作为参数的 Promise 实例自己定义了 catch 方法，那么它一旦被 rejected，并不会出发 Promise.all 的 catch 方法。\nconst p1 = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#34;hello\u0026#34;); }).then((result) =\u0026gt; { console.log(\u0026#34;p1 result: \u0026#34;, result); return result; }) .catch((e) =\u0026gt; { console.log(\u0026#34;p1 catch: \u0026#34;, e); return e; }); const p2 = new Promise((resolve, reject) =\u0026gt; { throw new Error(\u0026#34;报错\u0026#34;); }).then((result) =\u0026gt; { console.log(\u0026#34;p2 result: \u0026#34;, result); return result; }) .catch((e) =\u0026gt; { console.log(\u0026#34;p2 catch: \u0026#34;, e); return e; }); const p3 = Promise.all([p1, p2]).then((result) =\u0026gt; { console.log(result); // [\u0026#34;hello\u0026#34;, Error: 报错] }).catch((e) =\u0026gt; console.log(e));\r如果 p2 没有自己的 catch 方法，就会调用 Promise.all 的 catch。\nconst p1 = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#34;hello\u0026#34;); }).then((result) =\u0026gt; result); const p2 = new Promise((resolve, reject) =\u0026gt; { throw new Error(\u0026#34;报错\u0026#34;); }).then((result) =\u0026gt; result); Promise.all([p1, p2]) .then((result) =\u0026gt; console.log(result)) .catch((e) =\u0026gt; console.log(e)); // Error: 报错 2. race Promise.race() 同样是将多个 Promise 实例包装成一个新的 Promise 实例。\nconst p = Promise.race([p1, p2, p3]);\r只要 p1、p2、p3 之中有一个实例的状态发生了改变，p 的状态就会随之改变。率先改变的 Promise 实例的返回值会传递给 p 的回调函数。\nconst p = Promise.race([ fetch(\u0026#34;/resource-that-may-take-a-while\u0026#34;), new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; reject(new Error(\u0026#34;request timeout\u0026#34;)), 5000) }) ]); p.then(console.log).catch(console.error);\r3. allSettled Promise.allSettled() 也是接受一组 Promise 实例作为参数包装成一个新的 Promise 实例。\nconst promise1 = Promise.resolve(3); const promise2 = new Promise((resolve, reject) =\u0026gt; { setTimeout(reject, 100); }); const promises = [promise1, promise2]; Promise.allSettled([promise1, promise2]).then((results) =\u0026gt; { results.forEach((result) =\u0026gt; console.log(result.status)); }); // 输出 // fulfilled // rejected 只有等这些参数实例都返回结果，不管是 fulfilled 还是 rejected，包装实例才会结束。\n4. resolve Promise.resolve() 将现有对象转为 Promise 对象。\nPromise.resolve(\u0026#34;foo\u0026#34;); // 等价于 new Promise((resolve) =\u0026gt; resolve(\u0026#34;foo\u0026#34;));\r参数可分为四种情况：\n参数是一个 Promise 实例，Promise.resolve 将不做任何修改，原封不动的返回这个实例。 参数是一个 thenable 对象，Promise.resolve 会将这个对象转为 Promise 对象然后立即执行 thenable 对象的 then 方法。 参数不是具有 then 方法的对象，或根本不是对象，Promise.resolve 会返回一个新的 Promise 对象，状态为 resolved 没有参数时直接返回一个 resolved 状态的 Promise 对象。 5. reject Promise.reject() 返回一个新的 Promise 实例，该实例的状态为 rejectd。\nconst p = Promise.reject(\u0026#34;出错\u0026#34;); // 等价于 const p = new Promise((resolve, reject) =\u0026gt; reject(\u0026#34;出错\u0026#34;)); p.then(null, (s) =\u0026gt; console.log(s)); // 出错 Promise.reject() 方法的参数会原封不动的变成后续方法的参数：\nPromise.reject(\u0026#34;出错\u0026#34;).catch((e) =\u0026gt; { console.log(e === \u0026#34;出错\u0026#34;); // true });\r4. 使用场景 1. 将图片的加载写成 Promise，一旦加载完成则状态发生改变 const preloadImage = (path) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; }); };\r2. 通过链式操作将多个渲染数据分给不同的 then，让其各司其职。或当下一个异步请求依赖上个请求的结果时，也可以通过链式操作解决问题 // 各司其职 getInfo().then((res) =\u0026gt; { let { bannerList } = res; // 渲染轮播图 console.log(bannerList); return res; }).then((res) =\u0026gt; { let { shortList } = res; // 渲染店铺列表 console.log(shortList); return res; }).then((res) =\u0026gt; { let { categoryList } = res; // 渲染分类列表 console.log(categoryList); return res; });\r3. 通过 all 实现多个请求合并，汇总所有请求结果。比如加载 loading 时，只用设置一个 loading function initLoad() { loading.show() // 加载 loading Promise.all([getBannerList(), getStoreList(), getCategoryList()]).then((res) =\u0026gt; { console.log(res); loading.hide(); // 关闭 loading }).catch((err) =\u0026gt; { console.log(err); loading.hide(); // 关闭 loading }) } initLoad(); // 数据初始化 4. 通过 race 设置图片请求超时 // 请求某个图片资源 function requestImg() { let p = new Promise((resolve, reject) =\u0026gt; { let img = new Image(); img.onload = function() { resolve(img); } // 正确的资源 //img.src = \u0026#34;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg\u0026#34;; img.src = \u0026#34;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1\u0026#34;; }); return p; } // 延时函数，给请求计时 function timeout() { let p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { reject(\u0026#34;图片请求超时\u0026#34;); }, 5000); }); return p; } Promise.race([requestImg(), timeout()]).then((results) =\u0026gt; { console.log(results); }).catch((err) =\u0026gt; { console.log(err); })\r5. 面试回答 Promise 是异步编程的一种解决方案，目的是为了解决传统编写异步操作时的回调地狱问题。 Promise 的优点是链式操作降低了编码难度，代码可读性增加。 Promise 对象有且仅有三种状态：pending，fulfilled，rejected。 Promise 对象是一个构造函数，用于生成 Promise 实例。该函数的两个参数分别是 resolve 和 reject，这两个参数也都是函数。它们的作用是改变 Promise 的状态。resolve 可以将对象从 pending 转为 resolved，reject 将对象从 pending 转为 rejected。 Promise 的状态发生改变后，不会再次改变，且我们任何时候都可以得到这个结果。这与事件不同，事件的特点是错过后无法得到结果。 Promise 一旦创建就无法取消，如果我们不设置回调函数，Promise 内部抛出的错误不会反映到外部。 Promise 的实例方法有 then，catch，finally。 then 是实例状态发生改变时的回调函数，它属于微任务，会在本轮事件循环的末尾进行。它有两个参数，第一个参数是 resolved 状态的回调函数，第二个参数是 rejected 状态的回调函数。then 返回一个新的 Promise 实例，这也是 Promise 能够链式书写的原因。 catch 是 .then(null, rejection) 的简写，用于指定发生错误时的回调函数。Promise 对象的错误具有“冒泡”性质，它会一直往后传递直到被捕获为止。一般来说我们使用的 then 往往只有一个参数，这是因为我们可以用 catch 来代替第二个参数。Promise 抛出的错误不会传递到外部代码，即不会中断进程。 finally 用于指定不管 Promise 对象最后的状态如何都要执行的代码。 Promise 构造函数的方法有 all，race，allSettled，resolve，reject等。 Promise.all()，Promise.race()，Promise.allSettled() 都是将一组 Promise 实例作为参数包装成一个新的 Promise 实例。 假设接受一个有三个 Promise 实例的数组 Promise.all() 是只有三个实例的状态都变为 fulfilled，返回的 Promise 实例的状态才会变成 fulfilled，此时三个实例的返回值作为一个数组传递给这个Promise 实例的回调函数；如果有一个被 rejected，则返回的 Promise 实例被 rejected，此时第一个被 rejected 的实例的返回值会被传递给 Promise 的回调函数。 Promise.race() 则是只要有一个实例的状态发生改变，则返回的 Promise 实例的状态就会随之改变，率先改变的实例的返回值会传递给 Promise 的回调函数。 Promise.allSettled() 则是要三个实例的状态都改变完成后，返回的 Promise 实例才会改变状态。且三个实例的返回值作为数组传给回调函数。 ","date":"2024-04-09","id":6,"permalink":"/docs/interview/javascript/%E8%AF%B4%E8%AF%B4%E5%AF%B9-promise-%E7%9A%84%E7%90%86%E8%A7%A3/","summary":"1. 介绍 Promise 意为承诺，是异步编程的一种解决方案，比传统的回调函数更合理、强大。\n在以前处理多层异步操作时，我们通常会这样编写代码：\ndoSomething(function(result) { doSomethingElse(result, function(newResult) { doThridThing(newResult, function(finalResult) { console.log(\u0026#34;得到最终结果: \u0026#34; + finalResult); }, failureCallback); }, failureCallback); }, failureCallback);\r上面的代码阅读困难，这就是经典的回调地狱。","tags":[],"title":"说说对 Promise 的理解"},{"content":"","date":"2023-09-07","id":7,"permalink":"/docs/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"2023-09-07","id":8,"permalink":"/privacy/","summary":"","tags":[],"title":"Privacy Policy"},{"content":"","date":"2023-09-07","id":9,"permalink":"/","summary":"","tags":[],"title":"化 道 两 千"},{"content":"","date":"0001-01-01","id":10,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":11,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":12,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]