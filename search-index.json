[{"content":"Well-thought-through product announcements will help increase feature awareness and engage users with new functionality. Just like sharing your public roadmap, it\u0026rsquo;s also a great way to let potential customers see that you\u0026rsquo;re constantly improving.\nFurther reading Read How to announce product updates and features ","date":"2023-09-07","id":0,"permalink":"/blog/example-post/","summary":"You can use blog posts for announcing product updates and features.","tags":[],"title":"Example Post"},{"content":"","date":"2023-09-07","id":1,"permalink":"/blog/","summary":"","tags":[],"title":"Blog"},{"content":"","date":"2023-09-07","id":2,"permalink":"/docs/javascript/","summary":"","tags":[],"title":"JavaScript"},{"content":"","date":"2023-09-07","id":3,"permalink":"/docs/interview/","summary":"","tags":[],"title":"面试题"},{"content":"","date":"2024-04-09","id":4,"permalink":"/docs/interview/javascript/","summary":"","tags":[],"title":"JavaScript"},{"content":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\nFurther reading Read about reference in the Diátaxis framework ","date":"2023-09-07","id":5,"permalink":"/docs/javascript/js-%E5%9F%BA%E7%A1%80/","summary":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.","tags":[],"title":"JS 基础"},{"content":"1. 介绍 Promise 意为承诺，是异步编程的一种解决方案，比传统的回调函数更合理、强大。\n在以前处理多层异步操作时，我们通常会这样编写代码：\ndoSomething(function(result) { doSomethingElse(result, function(newResult) { doThridThing(newResult, function(finalResult) { console.log(\u0026#34;得到最终结果: \u0026#34; + finalResult); }, failureCallback); }, failureCallback); }, failureCallback);\r上面的代码阅读困难，这就是经典的回调地狱。\n现在通过 Promise 改写上方代码：\ndoSomething().then((result) =\u0026gt; { return doSomethingElse(result); }).then((newResult) =\u0026gt; { return doThirdThing(newResult); }).then((finalResult) =\u0026gt; { console.log(\u0026#34;得到最终结果: \u0026#34; + finalResult); }).catch(failureCallback);\r我们在这里就能体会到 Promise 解决异步操作时的优点了：\n链式操作降低了编码难度 代码可读性增加 下面我们来正式介绍下 Promise： Promise 对象是一个构造函数，用来生成 Promise 实例\nconst promise = new Promise((resolve, reject) =\u0026gt; {});\rPromise 对象有且仅有三种状态：\npending 进行中 fulfilled 已成功 rejected 已失效 Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject，它们也都是函数。Promise 状态的改变是通过 resolve() 和 reject() 两个函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态。\nresolve 函数用于将 Promise 对象的状态从 pending 转为 fulfilled。 reject 函数用于将 Promise 对象的状态从 pending 转为 rejected。 Promise 对象的状态不受外界影响，只有异步操作的结果可以决定当前处于哪一种状态。 当把一个任务交给 Promise 时，它的状态就是 pending，任务完成时转为 fulfilled，失败时转为 rejected。当状态发生过转换后，之后状态不会再次改变，且任何时候我们都可以得到这个结果。这与事件不同，事件的特点是当我们错过后，是无法得到结果的。\n简单来说的话，Promise 就是一个容器，里面保存着某个未来才会结束的任务（通常为一个异步操作）的结果。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n我们无法取消 Promise，一旦创建，它就会立即执行，无法中途取消，如果不设置回调函数，Promise 内部抛出的错误不会反映到外部，当处于 pending 状态时，无法得知目前进展到哪一阶段（刚刚开始还是即将结束）\n阅读下图我们能轻松了解 Promise 的工作流程：\ngraph LR;\rA([Promise]) -- \"pending -\u003e fulfill\" --\u003e B([\".then(onFUlfillment)\"]) --\u003e F([async actions]) -- return --\u003e D([Promise])\rA([Promise]) -- \"pending -\u003e reject\" --\u003e C([\".then(onRejection)\r.catch(onRejection)\"]) --\u003e E([error handing]) -- return --\u003e D([Promise])\rD -- \"pending -\u003e ...\" --\u003e G([\".then().catch()\"])\r2. 实例方法 我们常用的 Promise 实例方法有以下几种：\n1. then then 是实例状态发生改变时的回调函数，它可以为两个状态的改变注册回调函数，这个回调函数属于微任务，会在本轮事件循环的末尾进行。第一个参数是 resolved 状态的回调函数，第二个参数是 rejected 状态的回调函数。\nthen 方法返回的是一个新的 Promise 实例，这也是 Promise 能够链式书写的原因。\ngetJSON(\u0026#34;/post.json\u0026#34;).then((json) =\u0026gt; { return json.post; }).then((post) =\u0026gt; { // ... });\r2. catch catch() 是 .then(null, rejection) 或 .then(undefined, rejection) 的另一种写法，用于指定发生错误时的回调函数。\ngetJSON(\u0026#34;/posts.json\u0026#34;).then((posts) =\u0026gt; { // ... }).catch((error) =\u0026gt; { console.log(\u0026#34;发生错误！\u0026#34;, error); });\rPromise 对象的错误具有“冒泡”性质，它会一直向后传递，直到被捕获为止。\ngetJSON(\u0026#34;/post/1.json\u0026#34;).then((post) =\u0026gt; { return getJSON(post.commentURL); }).then((comments) =\u0026gt; { // some code }).catch((error) =\u0026gt; { // 处理前面三个 Promise 产生的错误 })\r一般来说，我们使用 then() 时往往只有一个参数，这是因为我们可以用 catch 方法代替 then() 的第二个参数。\nPromise 对象抛出的错误不会传递到外层代码，即不会有任何反应；\nconst someAsyncThing = () =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { resolve(x + 2); // Reference Error: x is not defined }) }\r这里的代码会抛出错误，但是并不会中断进程。因为 Promise 内部的错误不会影响到外部环境。\ncatch() 方法之中还能再抛出错误，通过后面的 catch() 去捕获。\n3. finally finally() 方法用于指定不管 Promise 对象最后状态如何，都要执行的代码段：\npromise.then((result) =\u0026gt; {...}) .catch((error) =\u0026gt; {...}) .finally(() =\u0026gt; {...})\r构造函数方法 1. all Promise.all() 用于将多个 Promise 包装成一个新的 Promise 实例。\nconst promise = Promise.all([p1, p2, p3]);\r它接受一个数组（迭代对象）作为参数，数组成员都应该是 Promise 实例。\n实例 promise 的状态由 p1、p2、p3 共同决定，分为两种情况：\n只有 p1、p2、p3 的状态都变为 fulfilled，promise 实例的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组传递给 promise 的回调函数。 只要 p1、p2、p3 之中有一个被 rejected，promise 的状态就变成 rejected。此时第一个被 rejected 的实例的返回值会被传递给 promise 的回调函数。 {{ if .Store.Get \u0026ldquo;hasMermaid\u0026rdquo; }}\n{{ end }}\n","date":"2024-04-09","id":6,"permalink":"/docs/interview/javascript/%E8%AF%B4%E8%AF%B4%E5%AF%B9-promise-%E7%9A%84%E7%90%86%E8%A7%A3/","summary":"1. 介绍 Promise 意为承诺，是异步编程的一种解决方案，比传统的回调函数更合理、强大。\n在以前处理多层异步操作时，我们通常会这样编写代码：\ndoSomething(function(result) { doSomethingElse(result, function(newResult) { doThridThing(newResult, function(finalResult) { console.log(\u0026#34;得到最终结果: \u0026#34; + finalResult); }, failureCallback); }, failureCallback); }, failureCallback);\r上面的代码阅读困难，这就是经典的回调地狱。","tags":[],"title":"说说对 Promise 的理解"},{"content":"","date":"2023-09-07","id":7,"permalink":"/docs/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"2023-09-07","id":8,"permalink":"/privacy/","summary":"","tags":[],"title":"Privacy Policy"},{"content":"","date":"2023-09-07","id":9,"permalink":"/","summary":"","tags":[],"title":"化 道 两 千"},{"content":"","date":"0001-01-01","id":10,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":11,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":12,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]